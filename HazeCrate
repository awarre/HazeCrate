#!/usr/bin/python3
"""
Launches DOS executable in DOSBox from Steam compatibility tool parameters.
"""

# REFERENCES
# https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/master/docs/steam-compat-tool-interface.md

import sys
import os
import configparser
import shlex
import argparse
import hashlib
from pathlib import Path
import game_select_menu
import parse_sierralauncher


# CONFIGURATION
DEBUG = True
DOSBOX_PATH = 'io.github.dosbox-staging'

# GLOBAL CONSTANTS
HOME = os.path.expanduser("~")
STEAM_APP_ID = str(os.environ.get("STEAM_COMPAT_APP_ID"))
STEAM_GAME_INSTALL_PATH = str(os.environ.get("STEAM_COMPAT_INSTALL_PATH"))
STEAM_INSTALL_PATH = str(os.environ.get("STEAM_COMPAT_CLIENT_INSTALL_PATH"))
SCRIPT_PATH = str(os.path.dirname(__file__))
DEBUG_LOG_PATH = SCRIPT_PATH + '/debug/debug_' + STEAM_APP_ID + '.log'

if os.path.exists(DEBUG_LOG_PATH):
    os.remove(DEBUG_LOG_PATH)


def write_debug_line(line: str):
    """
    Writes string to debug log.

    Parameters
    ----------
    line : str
        String to log.
    """
    if DEBUG:
        with open(DEBUG_LOG_PATH, 'a', encoding='utf-8') as f:
            f.write(line + '\n')


def write_new_dosbox_config_line(line: str, auto_conf_path: str):
    """
    Writes string as new line to DOSBox auto config file.

    Parameters
    ----------
    line : str
        String to write.
    auto_conf_path : str
        Path to the new DOSBox config file.
    """
    try:
        with open(auto_conf_path, 'a', encoding='utf-8') as f:
            f.write(line + '\n')
    except OSError as e:
        error = "Can't save config: " + auto_conf_path + "Exception: " + str(e)
        write_debug_line(error)


def file_exists_ci(path: str) -> str:
    """
    Case-insensitive check if path exists. Returns corrected case.

    Parameters
    ----------
    path : str
        File path to validate.

    Returns
    -------
    str
        Case corrected file path, or empty string if path doesn't exist.
    """
    # Look for path regardless of case
    if not os.path.exists(path):
        write_debug_line('invalid path: ' + path)
        if '/' in path:
            parent_dir = os.path.dirname(path)
            write_debug_line('parent dir path: ' + parent_dir)
        else:
            parent_dir = './'
        for p in os.listdir(parent_dir):
            if str(p).lower() == str(os.path.basename(path)).lower():
                write_debug_line('valid path: ' + path)
                return str(os.path.join(parent_dir, p))
        # No file found?
        return ''
    return str(path)


def create_dosbox_autoconf_path(conf_path: str) -> str:
    """
    Determines the location of the DOSBox auto config file, creating any directories needed.

    Parameters
    ----------
    conf_path : str
        Default dosbox.conf path from Steam arguments.

    Returns
    -------
    str
        Returns the path to the new DOSBox auto config file for this game.
    """
    # Base directory
    path = get_new_dosbox_conf_dir(conf_path)
    p = Path(path)
    p.mkdir(parents=True, exist_ok=True)
    # Hash for each dosbox config. Some games have different config options.
    string_hash = get_dosbox_conf_hash(conf_path)
    game_dir = os.path.basename(STEAM_GAME_INSTALL_PATH)
    # conf_file_name = 'AUTO_' + STEAM_APP_ID + '_' + string_hash + '.conf'
    new_conf_file = f"AUTO_{STEAM_APP_ID}_{string_hash}.conf"
    # path = SCRIPT_PATH + "/configs/" + game_dir + '/' +
    path = f"{SCRIPT_PATH}/configs/{game_dir}/{new_conf_file}"
    # write_debug_line('Conf Hash: ' + string_hash)
    # Cleanup old autogenerated config
    if os.path.exists(path):
        os.remove(path)
    return path


def get_new_dosbox_conf_dir(conf_path: str):
    """
    Determines the base directory for the new game DOSBox config files.

    Parameters
    ----------
    conf_path : str
        Location of the default DOSBox config found from Steam arguments.

    Returns
    -------
    _type_
        Returns the directory where the game's new DOSBox config files will be stored.
    """
    # Game specific config directory
    game_dir = os.path.basename(STEAM_GAME_INSTALL_PATH)
    conf_path = f"{SCRIPT_PATH}/configs/{game_dir}"
    return conf_path


def update_autoexec_section(conf: list) -> list:
    """
    Converts [autoexec] section from DOSBox config to proper Linux format.

    Parameters
    ----------
    conf : list
        Existing [autoexec] section from default DOSBox config.

    Returns
    -------
    list
        Modified [autoexec] section of config.
    """
    auto_exec_conf = []
    # Find [autoexec] section
    for line in conf:
        # line is [autoexec], or already found it, and line isn't empty
        if (line.lower() == '[autoexec]' or auto_exec_conf) and line:
            # Stop if we find another section header
            if (line[0] == '[' and line.lower() != '[autoexec]'):
                break
            auto_exec_conf.append(line)

    # [autoexec] sections can be an absolute mess, try to clean it up.
    for i, line in enumerate(auto_exec_conf):
        # Fix the paths for a Linux environment
        line = line.replace('\\', '/')

        # Try to fix the case senstitivity in mount lines...
        if line.lower().startswith('mount'):
            line = update_mount(line)

        # Try to fix the case senstitivity in imgmount lines...
        if line.lower().startswith('imgmount'):
            line = update_imgmount(line)

        auto_exec_conf[i] = line
    return auto_exec_conf


def update_mount(line: str) -> str:
    """
    Updates the mount commmand from default config to work on Linux.

    Parameters
    ----------
    line : str
        Existing mount command.

    Returns
    -------
    str
        Updated mount command.

    Notes
    -------
    `DOSBox MOUNT Command https://www.dosbox.com/wiki/MOUNT`_
    """
    args = shlex.split(line)
    args[2] = convert_mount_command_path_format(args[2])
    line = ' '.join(args)
    return line


def update_imgmount(line: str) -> str:
    """
    Updates the imgmount commmand from default config to work on Linux.

    Parameters
    ----------
    line : str
        Existing imgmount command.

    Returns
    -------
    str
        Updated imgmount command.

    Notes
    -------
    `DOSBox IMGMOUNT Command https://www.dosbox.com/wiki/IMGMOUNT`_
    """
    args = shlex.split(line)
    for i, arg in enumerate(args):
        if str(arg).replace('"', '').lower().endswith('.iso'):
            args[i] = convert_mount_command_path_format(arg)
    line = ' '.join(args)
    return line


def convert_mount_command_path_format(path: str) -> str:
    """
    Resolves case-corrected absolute (img)mount paths.

    Parameters
    ----------
    path : str
        Existing path from command.

    Returns
    -------
    str
        Case-corrected absolute path.
    """
    path_dirs = (path.replace('"', '')).split('/')
    valid_path = os.getcwd()
    for d in path_dirs:
        valid_path = valid_path + '/' + d
        search_path = Path(valid_path)
        valid_path = file_exists_ci(str(search_path.resolve()))
    new_path = f'"{str(Path(valid_path).resolve())}"'
    return new_path


def get_dosbox_conf_hash(path: str) -> str:
    """
    Generates an 8 character hash from a string.

    Parameters
    ----------
    path : str
        String to hash.

    Returns
    -------
    str
        8 character hash string.

    Notes
    -------
    Unique auto config files for each game launch option. Many games have multiple configs.
    """
    hash_string = str(hashlib.sha256(path.encode()).hexdigest())
    hash_string = hash_string[-8:]
    return hash_string


def parse_args(args: list) -> argparse.Namespace:
    """
    Parse DOSBox command line arguments and paths from Steam args

    Parameters
    ----------
    args : list
        Arguments list from sys.argv

    Returns
    -------
    argparse.Namespace
        Returns an argparse Namespace with the DOSBox arguments received from Steam

    Notes
    `DOSBox Command Line Parameters https://www.dosbox.com/wiki/Usage`_
    """

    # Check if game has dosbox params in batch file
    if args[2].endswith('.bat'):
        write_debug_line('Batch file: ' + args[2])
        args = parse_batch(args)
    else:
        write_debug_line(args[2])

    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('compatpath', nargs='?', default='')
    arg_parser.add_argument('--dosbox', nargs='+', default='')
    arg_parser.add_argument('-conf', help='DOSBox configuration file.', action='append')
    arg_parser.add_argument('-exit', action='store_true')
    arg_parser.add_argument('-c', nargs='?')
    arg_parser.add_argument('-fullscreen', action='store_true')
    arg_parser.add_argument('-lang')
    arg_parser.add_argument('-machine')
    arg_parser.add_argument('-noconsole', action='store_true')
    arg_parser.add_argument('-startmapper', action='store_true')
    arg_parser.add_argument('-noautoexec', action='store_true')
    arg_parser.add_argument('-securemode', action='store_true')
    arg_parser.add_argument('-scaler')
    arg_parser.add_argument('-forcescaler')
    arg_parser.add_argument('-version', action='store_true')
    arg_parser.add_argument('-socket')
    arg_parser.add_argument('-editconf')
    arg_parser.add_argument('-opencaptures')
    arg_parser.add_argument('-printconf', action='store_true')
    arg_parser.add_argument('-eraseconf', action='store_true')
    arg_parser.add_argument('-erasemapper')
    results = arg_parser.parse_args(args)

    if not results.conf:
        write_debug_line('No DOSBox config found, using default.')
        results.conf = ['dosbox.conf']

    return results


def parse_batch(args: list) -> list:
    "Checks batch file for dosbox parameters"
    if os.path.exists(args[2]):
        write_debug_line('Batch file found: ' + args[2])
        with open(args[2], 'r', encoding='utf-8') as f:
            data = f.read().splitlines()
        for line in data:
            if 'dosbox' in line.lower():
                line = line.replace('\\', '/')
                write_debug_line('Dosbox param found in batch file')
                batch_args = shlex.split(line)
                del args[2]
                args.extend(batch_args)
    return args


def new_dosbox_command(args: argparse.Namespace) -> str:
    """
    Returns the new DOSBox command to run including new config files.

    Parameters
    ----------
    args : argparse.Namespace
        Arguments received from Steam.

    Returns
    -------
    str
        Returns the new command to launch the game.
    """
    command = []
    auto_conf_path = create_auto_dosbox_conf(args)
    # flatpak run and set filesystem path
    flatpak_cmd = f'flatpak run --filesystem="{SCRIPT_PATH}" --filesystem="{STEAM_INSTALL_PATH}"'
    command.append(flatpak_cmd)
    # DOSBox flatpak to use
    command.append(DOSBOX_PATH)
    # Executable if it was listed
    if len(args.dosbox) > 1:
        exe_path = STEAM_GAME_INSTALL_PATH + '/' + (args.dosbox[1]).replace('\\', '/')
        exe_path = file_exists_ci(exe_path)
        command.append(shlex.quote(exe_path))
    # New DOSBox config
    command.append("-conf")
    command.append(shlex.quote(auto_conf_path))
    # Make sure we exit DOSBox when the game exits
    command.append("-exit")
    # Create command string from array
    cmd_string = str(" ".join(command))

    return cmd_string


def get_dosbox_conf_global_template() -> list:
    """
    Gives path to DOSBOX config template to override with settings better for Steam Deck

    Returns
    -------
    list
        Returns the template config as a list.
    """
    path = os.path.dirname(__file__) + '/global_dosbox.conf'
    with open(path, 'r', encoding='utf-8') as file:
        lines = file.read()

    return lines


def get_dosbox_conf_custom_template(conf_path: str) -> list:
    """
    Returns custom DOSBox config for game

    Parameters
    ----------
    conf_path : str
        Path to existing default DOSBox config file

    Returns
    -------
    list
        Lines of the custom.conf file. Empty string if it doesn't exist.
    """
    path = get_new_dosbox_conf_dir(conf_path) + '/custom.conf'
    if os.path.exists(path):
        write_debug_line("custom.conf found: " + path)
        with open(path, 'r', encoding='utf-8') as file:
            lines = file.read()
    else:
        lines = ''
    return lines


def get_default_dosbox_conf_path(conf: str) -> str:
    """
    Locate the default DOSBox config and convert it to absolute Linux path.

    Parameters
    ----------
    conf : str
        Path to the DOSBox conf file from Steam arguments.

    Returns
    -------
    str
        Returns Linux path to config file.
    """
    if conf:
        write_debug_line('DOSBox config found: ' + conf)
        path = os.getcwd() + '/' + str(conf).replace('\\', '/')
        write_debug_line("Conf path: " + path)
        # Try to make relative path more absolute
        if STEAM_GAME_INSTALL_PATH not in path:
            path = STEAM_GAME_INSTALL_PATH + '/' + path
        path = file_exists_ci(path)
    else:
        write_debug_line('No config found. Is this even a DOSBox game?')
    return path


def get_default_dosbox_conf_data(path: str) -> list:
    """
    Returns the DOSBox conf file as a list of strings.

    Parameters
    ----------
    path : str
        Path to DOSBox config file.

    Returns
    -------
    list
        DOSBox config file lines as list of strings.
    """
    encodings = ['utf-8', 'windows-1250', 'windows-1252']
    for encode in encodings:
        try:
            with open(path, 'r', encoding=encode) as file:
                lines = file.read().splitlines()
            write_debug_line("Encoding: " + encode)
        except OSError as e:
            write_debug_line("Couldn't open config. Exception: " + str(e))
        except Exception as e:
            write_debug_line("Couldn't open config. Exception: " + str(e))
        else:
            break

    return lines


def create_auto_dosbox_conf(args: argparse.Namespace):
    """
    Creates new DOSBox configuration file for game based on existing configs.

    Parameters
    ----------
    args : argparse.Namespace
        Arguments received from Steam.
    Returns
    -------
    str
        Path to the DOSBox config file generated.
    Notes
    -----
    DOSBox config file order of precedence (higher overrides lower):
    1. Custom (per-game custom config)
    2. Global Template (default included with HazeCrate)
    3. Default (included with game)

    `DOSBox.conf https://www.dosbox.com/wiki/Dosbox.conf`_
    `DOSBox-staging Config file examples
    https://github.com/dosbox-staging/dosbox-staging/wiki/Config-file-examples`_

    """
    auto_conf_path = create_dosbox_autoconf_path(args.conf[0])
    config = configparser.ConfigParser()

    for p in args.conf:
        path = get_default_dosbox_conf_path(p)
        config_data = get_default_dosbox_conf_data(path)
        autoexec = update_autoexec_section(config_data)
        # Parse the game's included dosbox config
        try:
            write_debug_line('Config Path: ' + path)
            config.read(path)
            write_debug_line('Config read successfully!')
        # Usually exceptions are [autoexec] errors since configParser doesn't like the format.
        except configparser.MissingSectionHeaderError as e:
            write_debug_line('No section headers found: ' + path)
            write_debug_line('Exception: ' + str(e))
        except configparser.ParsingError as e:
            write_debug_line('Error parsing dosbox config file: ' + path)
            write_debug_line('Exception: ' + str(e))
        except configparser.Error as e:
            write_debug_line('ConfigParser Exception: ' + str(e))

    # Global config template will apply baseline settings.
    template_dosbox_conf = get_dosbox_conf_global_template()
    config.read_string(template_dosbox_conf)

    # Override included and global dosbox configs with custom settings
    custom_conf_path = get_new_dosbox_conf_dir(args.conf[0]) + '/custom.conf'
    custom_dosbox_conf = get_dosbox_conf_custom_template(custom_conf_path)
    config.read_string(custom_dosbox_conf)

    # Delete the [autoexec] section. We handle it separately
    config.remove_section('autoexec')

    # Save modified config
    for section in config.sections():
        write_new_dosbox_config_line('[' + section + ']', auto_conf_path)
        for (key, val) in config.items(section):
            write_new_dosbox_config_line(key + '=' + val, auto_conf_path)

    # Save [autoexec] section
    for line in autoexec:
        write_new_dosbox_config_line(line, auto_conf_path)
    return auto_conf_path


def find_menu_conf(args: list) -> list:
    "Locates menu config file and returns selection args"
    new_args = args
    if 'sierralauncher' in str(args).lower():
        for arg in args:
            if arg.endswith('SierraLauncher.exe'):
                menu_dir = os.path.dirname(arg)
                menu_path = f"{menu_dir}/SierraLauncher.ini"
                write_debug_line("SierraLauncher INI: " + menu_path)
                game_list = select_game_list(menu_path)
                new_args = create_menu_conf_args(game_list, menu_dir)
    if os.path.exists(os.path.basename(STEAM_GAME_INSTALL_PATH) + '/menu.ini'):
        write_debug_line('menu.ini')
    return new_args


def select_game_list(path: str):
    "Launches menu UI to select game. Returns game selection."
    game_list = parse_sierralauncher.GameList(path)
    if len(game_list.games_list) > 1:
        write_debug_line("Multiple games listed, creating menu.")
        menu = game_select_menu.GameMenu()
        menu.create_game_menu(game_list.games_list)
        menu.mainloop()
        game = game_select_menu.GameMenuButton.game_selection
    else:
        write_debug_line("Only one game found, returning as selection.")
        game = game_list.games_list[0]

    write_debug_line(f"Game selected: {game}")
    return game


def create_menu_conf_args(game: list, menu_path: str) -> list:
    "Creates valid launch args from menu list."
    rel_path = game.get('path').replace('\\', '/')
    game_path = f"{menu_path}/{rel_path}/"
    write_debug_line("Game Path: " + game_path)
    valid_path = ''
    for d in game_path.split('/'):
        write_debug_line("PATH: " + valid_path)
        valid_path = valid_path + '/' + d
        search_path = Path(valid_path)
        valid_path = file_exists_ci(str(search_path.resolve()))
    os.chdir(valid_path)
    exe_path = f"{valid_path}/{game.get('exe')}"
    args = [
        __file__,
        '--dosbox',
        exe_path
    ]
    args.extend(game.get('cmd').split())
    return args


def main():
    """
    Runs everything.
    """
    write_debug_line('APP ID: ' + STEAM_APP_ID)
    write_debug_line('INSTALL PATH: ' + STEAM_GAME_INSTALL_PATH)
    write_debug_line('HAZECRATE PATH: ' + SCRIPT_PATH)
    write_debug_line('Args: ' + str(sys.argv))
    args = find_menu_conf(sys.argv)
    args = parse_args(args)

    write_debug_line("Parsed args: " + str(args))
    cmd = new_dosbox_command(args)
    write_debug_line('CMD: ' + cmd)
    os.system(cmd)


if __name__ == "__main__":
    main()
